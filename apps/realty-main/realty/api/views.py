# Generated by Gemini AI by merging PRs #7, #8, #12
import json
from datetime import datetime, timedelta
from urllib.parse import urlencode
import secrets
import string

# Optional import for Stripe (not required for MVP development)
try:
    import stripe
except ImportError:
    stripe = None

from django.conf import settings
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.views.decorators.csrf import csrf_exempt, ensure_csrf_cookie
from django.utils.decorators import method_decorator
from django.middleware.csrf import get_token
from django.urls import reverse
from django.http import HttpResponseRedirect
from django.core.cache import cache
from django.db.models import Q

from rest_framework import generics, permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework.pagination import PageNumberPagination
from rest_framework_simplejwt.views import TokenRefreshView
from rest_framework_simplejwt.exceptions import TokenError
from django.core.mail import send_mail
from django.template.loader import render_to_string

from .models import OTPCode, Payment, PaymentEventAudit
from .serializers import (
    UserSerializer,
    RegisterSerializer,
    OTPLoginSerializer,
    PaymentSerializer,
    PaymentEventAuditSerializer,
    UserProfileSerializer,
    PropertySerializer,
    PropertySearchSerializer,
)

# Импорт реальных моделей
from realty.pfimport.models import PFListSale, PFListRent, Area, Building

User = get_user_model()

# --- Health Check ---
def health_check(request):
    """Simplified health check without any complex dependencies"""
    from django.http import JsonResponse
    try:
        return JsonResponse({
            "status": "ok", 
            "service": "realty-backend",
            "timestamp": str(timezone.now()),
            "debug": settings.DEBUG,
            "database": "configured" if 'default' in settings.DATABASES else "missing"
        })
    except Exception as e:
        return JsonResponse({
            "status": "error",
            "error": str(e),
            "message": "Health check failed"
        }, status=500)

# --- CSRF Token View ---
@method_decorator(ensure_csrf_cookie, name="get")
class CSRFTokenView(APIView):
    """Получение CSRF токена для frontend"""
    permission_classes = (permissions.AllowAny,)

    def get(self, request):
        csrf_token = get_token(request)
        return Response({
            'csrfToken': csrf_token,
            'message': 'CSRF token generated'
        })

# --- Authentication Views ---
class RegisterView(generics.CreateAPIView):
    queryset = User.objects.all()
    permission_classes = (permissions.AllowAny,)
    serializer_class = RegisterSerializer
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

class PasswordLoginView(APIView):
    """Обычная авторизация по email/username и паролю (для тестовых пользователей)"""
    permission_classes = (permissions.AllowAny,)
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
    
    def post(self, request, *args, **kwargs):
        from django.contrib.auth import authenticate
        
        username_or_email = request.data.get('username') or request.data.get('email')
        password = request.data.get('password')
        
        if not username_or_email or not password:
            return Response({
                'error': 'Username/email and password are required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        # Пробуем найти пользователя по email или username
        user = None
        try:
            # Сначала пробуем по email
            if '@' in username_or_email:
                user = User.objects.get(email=username_or_email)
            else:
                user = User.objects.get(username=username_or_email)
                
            # Проверяем пароль
            if user.check_password(password):
                # Создаем JWT токены
                refresh = RefreshToken.for_user(user)
                
                return Response({
                    'tokens': {
                        'refresh': str(refresh),
                        'access': str(refresh.access_token),
                    },
                    'user': {
                        'id': user.id,
                        'username': user.username,
                        'email': user.email,
                        'first_name': user.first_name,
                        'last_name': user.last_name,
                    },
                    'message': 'Login successful'
                })
            else:
                return Response({
                    'error': 'Invalid credentials'
                }, status=status.HTTP_400_BAD_REQUEST)
                
        except User.DoesNotExist:
            return Response({
                'error': 'Invalid credentials'
            }, status=status.HTTP_400_BAD_REQUEST)

class SendOTPView(APIView):
    """Отправка OTP кода на email"""
    permission_classes = (permissions.AllowAny,)
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
    
    def post(self, request):
        email = request.data.get('email')
        if not email:
            return Response({'error': 'Email is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        # Генерируем OTP код
        otp_code = ''.join([str(secrets.randbelow(10)) for _ in range(6)])
        
        # Пытаемся записать OTP в БД; при ошибке (например, миграции не применены) отвечаем мягко
        try:
            # Деактивируем старые коды для этого email
            OTPCode.objects.filter(email=email, is_used=False).update(is_used=True)
            
            # Создаем новый OTP код
            OTPCode.objects.create(
                email=email,
                code=otp_code,
                expires_at=timezone.now() + timedelta(minutes=10)
            )
            stored = True
        except Exception:
            # В MVP режиме не падаем 500, а возвращаем код без сохранения
            stored = False
            # Сохраняем код в кэше как мягкий фоллбек (10 минут)
            cache.set(f"otp:{email}", otp_code, timeout=600)
        
        # Для MVP возвращаем код в ответе (в продакшн отправлять на email)
        # Попытаемся отправить письмо, если SMTP настроен
        email_sent = False
        email_error = None
        try:
            subject = "Your OTP code"
            message = f"Your OTP code is: {otp_code}\nThis code will expire in 10 minutes."
            html_message = None  # шаблон опционален
            sent = send_mail(
                subject,
                message,
                settings.DEFAULT_FROM_EMAIL,
                [email],
                html_message=html_message,
                fail_silently=False,
            )
            email_sent = sent > 0
        except Exception as exc:
            email_error = str(exc)

        return Response({
            'message': 'OTP code sent successfully',
            'otp_code': otp_code,  # ТОЛЬКО ДЛЯ MVP! Убрать в продакшн
            'expires_in': 600,  # 10 minutes
            'email': email,
            'persisted': stored,
            'email_sent': email_sent,
            'email_error': email_error,
            'note': 'MVP: OTP code provided in response. In production, will be sent via email.'
        })


class VerifyOTPView(APIView):
    """Верификация OTP кода"""
    permission_classes = (permissions.AllowAny,)
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
    
    def post(self, request):
        email = request.data.get('email')
        code = request.data.get('code')
        
        if not email or not code:
            return Response({
                'error': 'Email and code are required'
            }, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            otp = OTPCode.objects.get(
                email=email,
                code=code,
                is_used=False,
                expires_at__gt=timezone.now()
            )
            
            # Создаем/получаем пользователя
            user, created = User.objects.get_or_create(
                email=email, 
                defaults={'username': email}
            )
            
            # Деактивируем OTP код
            otp.is_used = True
            otp.save()
            
            # Генерируем JWT токены
            refresh = RefreshToken.for_user(user)
            
            return Response({
                'message': 'OTP verified successfully',
                'access': str(refresh.access_token),
                'refresh': str(refresh),
                'user': {
                    'id': user.id,
                    'email': user.email,
                    'username': user.username,
                    'is_new_user': created
                }
            })
            
        except OTPCode.DoesNotExist:
            # Пробуем мягкий фоллбек из кэша
            cached_code = cache.get(f"otp:{email}")
            if cached_code and cached_code == code:
                user, created = User.objects.get_or_create(
                    email=email, defaults={'username': email}
                )
                refresh = RefreshToken.for_user(user)
                # Использованный код очищаем из кэша
                cache.delete(f"otp:{email}")
                return Response({
                    'message': 'OTP verified successfully (cache)',
                    'access': str(refresh.access_token),
                    'refresh': str(refresh),
                    'user': {
                        'id': user.id,
                        'email': user.email,
                        'username': user.username,
                        'is_new_user': created
                    }
                })
            return Response({
                'error': 'Invalid or expired OTP code'
            }, status=status.HTTP_400_BAD_REQUEST)
        except Exception:
            # На внутренние ошибки БД пробуем фоллбек кэша
            cached_code = cache.get(f"otp:{email}")
            if cached_code and cached_code == code:
                user, created = User.objects.get_or_create(
                    email=email, defaults={'username': email}
                )
                refresh = RefreshToken.for_user(user)
                cache.delete(f"otp:{email}")
                return Response({
                    'message': 'OTP verified successfully (cache)',
                    'access': str(refresh.access_token),
                    'refresh': str(refresh),
                    'user': {
                        'id': user.id,
                        'email': user.email,
                        'username': user.username,
                        'is_new_user': created
                    }
                })
            return Response({
                'error': 'Invalid or expired OTP code'
            }, status=status.HTTP_400_BAD_REQUEST)


class CheckUserView(APIView):
    """Проверка: существует ли пользователь с данным email"""
    permission_classes = (permissions.AllowAny,)

    def get(self, request, *args, **kwargs):
        email = request.query_params.get('email')
        if not email:
            return Response({'error': 'Email is required'}, status=status.HTTP_400_BAD_REQUEST)
        exists = User.objects.filter(email=email).exists()
        return Response({'email': email, 'exists': exists})


class OTPLoginView(APIView):
    """Legacy OTP login view - совместимость со старым API"""
    permission_classes = (permissions.AllowAny,)

    def post(self, request, *args, **kwargs):
        serializer = OTPLoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        email = serializer.validated_data["email"]
        code = serializer.validated_data["code"]

        try:
            otp = OTPCode.objects.get(
                email=email,
                code=code,
                is_used=False,
                expires_at__gt=timezone.now()
            )
            user, created = User.objects.get_or_create(email=email, defaults={'username': email})
            
            otp.is_used = True
            otp.save()

            refresh = RefreshToken.for_user(user)
            return Response({
                "refresh": str(refresh),
                "access": str(refresh.access_token),
                "user": UserSerializer(user).data
            })
        except OTPCode.DoesNotExist:
            return Response({"error": "Invalid or expired OTP."}, status=status.HTTP_400_BAD_REQUEST)


class LogoutView(APIView):
    """Logs out the user by blacklisting their refresh token."""
    permission_classes = (permissions.IsAuthenticated,)

    def post(self, request):
        try:
            refresh_token = request.data["refresh_token"]
            token = RefreshToken(refresh_token)
            token.blacklist()
            return Response(status=status.HTTP_205_RESET_CONTENT)
        except Exception as e:
            return Response(status=status.HTTP_400_BAD_REQUEST)


class PasswordResetRequestView(APIView):
    permission_classes = (permissions.AllowAny,)
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

    def post(self, request):
        email = request.data.get('email')
        if not email:
            return Response({'error': 'Email is required'}, status=status.HTTP_400_BAD_REQUEST)
        
        try:
            user = User.objects.get(email=email)
        except User.DoesNotExist:
            # Не раскрываем, существует ли email
            return Response({'message': 'If an account with that email exists, a password reset link has been sent.'}, status=status.HTTP_200_OK)

        # Создаем токен для сброса пароля (для простоты используем OTP-логику)
        token = ''.join([str(secrets.randbelow(10)) for _ in range(20)])
        cache.set(f"password_reset:{token}", user.id, timeout=3600) # 1 час

        # В реальном проекте здесь будет отправка email
        # send_mail(...)
        
        # Для full-product возвращаем токен в ответе для простоты тестирования
        return Response({
            'message': 'Password reset token generated.',
            'token': token,
            'note': 'In a real product, this token would be sent via email.'
        })


class PasswordResetConfirmView(APIView):
    permission_classes = (permissions.AllowAny,)
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

    def post(self, request):
        token = request.data.get('token')
        password = request.data.get('password')
        
        if not token or not password:
            return Response({'error': 'Token and password are required'}, status=status.HTTP_400_BAD_REQUEST)

        user_id = cache.get(f"password_reset:{token}")
        if not user_id:
            return Response({'error': 'Invalid or expired token'}, status=status.HTTP_400_BAD_REQUEST)

        try:
            user = User.objects.get(id=user_id)
            user.set_password(password)
            user.save()
            cache.delete(f"password_reset:{token}")
            return Response({'message': 'Password has been reset successfully.'})
        except User.DoesNotExist:
            return Response({'error': 'User not found'}, status=status.HTTP_404_NOT_FOUND)


# --- User Profile Views ---
class UserProfileView(generics.RetrieveUpdateAPIView):
    queryset = User.objects.all()
    serializer_class = UserProfileSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_object(self):
        return self.request.user

# --- Admin Views ---
class StandardResultsSetPagination(PageNumberPagination):
    page_size = 100
    page_size_query_param = 'page_size'
    max_page_size = 1000

class UserProfileAdminView(generics.ListAPIView):
    queryset = User.objects.all().order_by('-date_joined')
    serializer_class = UserProfileSerializer
    permission_classes = [permissions.IsAdminUser]
    pagination_class = StandardResultsSetPagination

class PaymentAdminView(generics.ListAPIView):
    queryset = Payment.objects.all().order_by('-created_at')
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAdminUser]
    pagination_class = StandardResultsSetPagination

# --- Stripe Webhook View ---
class StripeWebhookView(APIView):
    permission_classes = [permissions.AllowAny]

    @csrf_exempt
    def post(self, request, *args, **kwargs):
        payload = request.body
        sig_header = request.META.get('HTTP_STRIPE_SIGNATURE')
        endpoint_secret = settings.STRIPE_WEBHOOK_SECRET

        try:
            if not stripe:
                return Response({"error": "Stripe not available"}, status=status.HTTP_501_NOT_IMPLEMENTED)
            event = stripe.Webhook.construct_event(
                payload, sig_header, endpoint_secret
            )
        except ValueError as e:
            # Invalid payload
            return Response(status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:  # Handle both Stripe errors and missing stripe module
            # Invalid signature
            return Response(status=status.HTTP_400_BAD_REQUEST)

        # Audit the event
        audit_entry, created = PaymentEventAudit.objects.get_or_create(
            provider="stripe",
            event_id=event.id,
            defaults={
                'event_type': event.type,
                'payload': json.loads(payload),
            }
        )
        if not created:
            # Event already processed, idempotent response
            return Response(status=status.HTTP_200_OK)

        # Handle the event
        if event.type == 'charge.succeeded':
            charge = event.data.object
            user_email = charge.billing_details.email
            user, _ = User.objects.get_or_create(email=user_email, defaults={'username': user_email})

            payment, p_created = Payment.objects.update_or_create(
                stripe_charge_id=charge.id,
                defaults={
                    'user': user,
                    'amount': charge.amount / 100.0,
                    'currency': charge.currency,
                    'status': charge.status,
                    'description': charge.description,
                }
            )
            audit_entry.related_payment = payment
        
        audit_entry.status = "processed"
        audit_entry.processed_at = timezone.now()
        audit_entry.save()

        return Response(status=status.HTTP_200_OK)


# --- Google OAuth Views ---

class GoogleAuthInitView(APIView):
    """Инициирует реальный Google OAuth процесс согласно Google Identity API"""
    permission_classes = (permissions.AllowAny,)
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
    
    def get(self, request):
        # Реальная Google OAuth интеграция
        state = secrets.token_urlsafe(32)
        cache.set(f"oauth_state_{state}", True, timeout=600)  # 10 минут
        
        # Реальная Google OAuth URL согласно документации
        base_url = "https://accounts.google.com/o/oauth2/v2/auth"
        params = {
            'client_id': settings.GOOGLE_OAUTH_CLIENT_ID,
            'redirect_uri': settings.GOOGLE_OAUTH_REDIRECT_URI,
            'scope': 'openid email profile',
            'response_type': 'code',
            'state': state,
            'access_type': 'online',
            'prompt': 'select_account'
        }
        
        auth_url = f"{base_url}?{urlencode(params)}"

        # Если запрошен прямой переход (браузер/ручной вызов), делаем редирект на Google.
        redirect_flag = request.query_params.get("redirect", "").lower() in {"1", "true", "yes"}
        accept_header = request.META.get("HTTP_ACCEPT", "")
        is_browser_html = ("text/html" in accept_header) and request.headers.get("X-Requested-With") is None
        if redirect_flag or is_browser_html:
            return HttpResponseRedirect(auth_url)

        # По умолчанию (UI через fetch) возвращаем JSON
        return Response({
            'auth_url': auth_url,
            'state': state,
            'message': 'Real Google OAuth - follow auth_url to authenticate'
        })


class GoogleAuthCallbackView(APIView):
    """Обрабатывает callback от Google OAuth и создает/авторизует пользователя"""
    permission_classes = (permissions.AllowAny,)
    
    @csrf_exempt
    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)
    
    def get(self, request):
        # Получаем параметры от Google OAuth callback
        code = request.GET.get('code')
        state = request.GET.get('state')
        error = request.GET.get('error')
        
        if error:
            return HttpResponseRedirect(f"{settings.FRONTEND_URL}/auth#error={error}")
            
        if not code or not state:
            return HttpResponseRedirect(f"{settings.FRONTEND_URL}/auth#error=missing_parameters")
        
        # Проверяем state для безопасности
        if not cache.get(f"oauth_state_{state}"):
            return HttpResponseRedirect(f"{settings.FRONTEND_URL}/auth#error=invalid_state")
        
        try:
            # Обмениваем authorization code на access token
            import requests
            
            token_url = "https://oauth2.googleapis.com/token"
            token_data = {
                'client_id': settings.GOOGLE_OAUTH_CLIENT_ID,
                'client_secret': settings.GOOGLE_OAUTH_CLIENT_SECRET,
                'code': code,
                'grant_type': 'authorization_code',
                'redirect_uri': settings.GOOGLE_OAUTH_REDIRECT_URI,
            }
            
            token_response = requests.post(token_url, data=token_data)
            token_json = token_response.json()
            
            if 'access_token' not in token_json:
                return HttpResponseRedirect(f"{settings.FRONTEND_URL}/auth#error=token_exchange_failed")
            
            # Получаем информацию о пользователе от Google
            user_info_url = f"https://www.googleapis.com/oauth2/v2/userinfo?access_token={token_json['access_token']}"
            user_response = requests.get(user_info_url)
            google_user_data = user_response.json()
            
            # Создаем или получаем пользователя
            user, created = User.objects.get_or_create(
                email=google_user_data['email'],
                defaults={
                    'username': google_user_data['email'],
                    'first_name': google_user_data.get('given_name', ''),
                    'last_name': google_user_data.get('family_name', ''),
                    'is_active': True,
                }
            )
            
            # Генерируем JWT токены
            refresh = RefreshToken.for_user(user)
            access_token = refresh.access_token
            
            # Редирект с токенами в hash для frontend (современный callback-роут)
            redirect_url = f"{settings.FRONTEND_URL}/auth/callback#access={access_token}&refresh={refresh}"
            return HttpResponseRedirect(redirect_url)
            
        except Exception as e:
            return HttpResponseRedirect(f"{settings.FRONTEND_URL}/auth#error=oauth_failed")


# --- Properties API Views ---

class PropertiesListView(generics.ListAPIView):
    """API для получения списка недвижимости (реальные данные)"""
    permission_classes = (permissions.AllowAny,)
    serializer_class = PropertySerializer
    pagination_class = StandardResultsSetPagination

    def get_queryset(self):
        # Объединяем queryset'ы из двух моделей
        # В реальном проекте, возможно, лучше использовать одну модель или view
        queryset = PFListSale.objects.select_related('area', 'building').all()
        # Тут можно добавить фильтрацию по параметрам запроса
        return queryset


class PropertyDetailView(generics.RetrieveAPIView):
    """API для получения детальной информации об объявлении"""
    permission_classes = (permissions.AllowAny,)
    serializer_class = PropertySerializer
    lookup_field = 'listing_id'

    def get_queryset(self):
        # Ищем в обеих моделях
        listing_id = self.kwargs.get('listing_id')
        if PFListSale.objects.filter(listing_id=listing_id).exists():
            return PFListSale.objects.select_related('area', 'building').all()
        return PFListRent.objects.select_related('area', 'building').all()


class AreasListView(generics.ListAPIView):
    """API для получения списка районов (реальные данные)"""
    queryset = Area.objects.all().order_by('name')
    permission_classes = (permissions.AllowAny,)
    # serializer_class = AreaSerializer  # Нужно будет создать AreaSerializer

    def list(self, request, *args, **kwargs):
        # Временное решение без сериализатора
        queryset = self.get_queryset()
        data = [{"id": area.id, "name": area.name} for area in queryset]
        return Response(data)


class PropertyStatsView(APIView):
    """API для получения статистики по недвижимости (реальные данные)"""
    permission_classes = (permissions.AllowAny,)
    
    def get(self, request):
        """Возвращает общую статистику по недвижимости (реальные данные)"""
        from django.db.models import Count, Avg

        total_properties = PFListSale.objects.count() + PFListRent.objects.count()
        total_buildings = Building.objects.count()
        avg_sale_price = PFListSale.objects.aggregate(avg_price=Avg('price'))['avg_price'] or 0

        stats = {
            'total_properties': total_properties,
            'total_buildings': total_buildings,
            'total_deals': total_properties, # Упрощенно
            'average_price': int(avg_sale_price),
            'data_source': 'real_database'
        }
        return Response(stats)


class BuildingsListView(APIView):
    """API для получения списка зданий (mock data)"""
    permission_classes = (permissions.AllowAny,)

    def get(self, request):
        mock_buildings = [
            {'id': 1, 'name': 'Marina Tower 1', 'area': 'Dubai Marina'},
            {'id': 2, 'name': 'Downtown Complex 2', 'area': 'Downtown Dubai'},
            {'id': 3, 'name': 'Business Center 3', 'area': 'Business Bay'},
        ]
        return Response(mock_buildings)


class ReportsView(APIView):
    """API для отчетов (mock data)"""
    permission_classes = (permissions.IsAuthenticated,)

    def get(self, request):
        # /api/reports/ and /api/reports/history/
        mock_history = [
            {'id': 1, 'report_type': 'property_analysis', 'generated_at': timezone.now() - timedelta(days=1), 'file_path': '/media/mock_report.pdf'},
            {'id': 2, 'report_type': 'market_overview', 'generated_at': timezone.now() - timedelta(days=5), 'file_path': '/media/mock_report.pdf'},
        ]
        return Response(mock_history)

    def post(self, request):
        # /api/reports/generate/
        report_type = request.data.get('report_type', 'custom_report')
        new_report = {
            'id': 3,
            'report_type': report_type,
            'generated_at': timezone.now(),
            'file_path': '/media/mock_report_new.pdf',
            'status': 'generating'
        }
        return Response(new_report, status=status.HTTP_201_CREATED)


class CreatePaymentIntentView(APIView):
    """API для создания Stripe Payment Intent"""
    permission_classes = (permissions.AllowAny,)  # Для MVP - без аутентификации

    def post(self, request):
        try:
            data = json.loads(request.body)
            amount = data.get('amount', 0)  # В центах
            currency = data.get('currency', 'usd')
            plan_name = data.get('plan_name', 'Unknown Plan')

            if not stripe:
                # Fallback для случаев когда stripe не установлен
                return Response({
                    'clientSecret': f'test_secret_{secrets.token_hex(16)}',
                    'test_mode': True
                })

            # Установка Stripe ключа
            stripe.api_key = getattr(settings, 'STRIPE_SECRET_KEY', 'sk_test_...')

            # Создание PaymentIntent
            intent = stripe.PaymentIntent.create(
                amount=amount,
                currency=currency,
                metadata={
                    'plan_name': plan_name,
                    'integration_check': 'accept_a_payment',
                },
                automatic_payment_methods={
                    'enabled': True,
                },
            )

            return Response({
                'clientSecret': intent.client_secret,
                'paymentIntentId': intent.id,
                'test_mode': False
            })

        except Exception as e:
            print(f"Stripe error: {e}")
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )
